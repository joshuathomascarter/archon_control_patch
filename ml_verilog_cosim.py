import os
import time
import struct # For reading binary entropy_bus.txt
import numpy as np

# Import the prediction function and constants from your LSTM predictor script
# Ensure chaos_lstm_predictor.py is in the same directory or accessible via PYTHONPATH
from chaos_lstm_predictor import load_predictor_model, SEQUENCE_LENGTH, NUM_FEATURES

# Define filenames
ENTROPY_BUS_FILENAME = "entropy_bus.txt"
ML_PREDICTIONS_FILENAME = "ml_predictions.txt"

def ml_verilog_cosim_driver(num_cycles: int = 100):
    """
    Runs the LSTM predictor in real-time on entropy/chaos/IPC variance signals.
    Reads entropy from entropy_bus.txt, simulates chaos and IPC variance,
    makes ML predictions, and writes them to ml_predictions.txt.

    Args:
        num_cycles (int): The number of simulation cycles to run.
    """
    print(f"Initializing ML-Verilog Co-Simulation Driver for {num_cycles} cycles...")

    # Load the trained LSTM model and scaler
    # This needs to be done only once at the start
    predict_action_func = load_predictor_model()
    if predict_action_func is None:
        print("Failed to load LSTM predictor. Ensure 'chaos_lstm_predictor.py' was run to generate 'model.h5' and 'scaler_params.npy'.")
        return

    # Open entropy_bus.txt for reading (binary mode)
    try:
        entropy_file = open(ENTROPY_BUS_FILENAME, 'rb')
        print(f"Opened '{ENTROPY_BUS_FILENAME}' for reading.")
    except FileNotFoundError:
        print(f"Error: '{ENTROPY_BUS_FILENAME}' not found. Please run 'generate_entropy_bus.py' first.")
        return
    except IOError as e:
        print(f"Error opening '{ENTROPY_BUS_FILENAME}': {e}")
        return

    # Create the output directory for ml_predictions.txt if it doesn't exist
    output_dir = os.path.dirname(ML_PREDICTIONS_FILENAME)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)
        print(f"Created output directory: {output_dir}")

    # Open ml_predictions.txt for writing
    try:
        predictions_file = open(ML_PREDICTIONS_FILENAME, 'w')
        print(f"Opened '{ML_PREDICTIONS_FILENAME}' for writing.")
    except IOError as e:
        print(f"Error opening '{ML_PREDICTIONS_FILENAME}': {e}")
        entropy_file.close()
        return

    # --- Co-simulation loop ---
    print(f"Starting co-simulation loop for {num_cycles} cycles...")
    for i in range(num_cycles):
        # 1. Read entropy value from entropy_bus.txt
        entropy_bytes = entropy_file.read(2) # Each entropy value is 16-bit (2 bytes), big-endian
        if not entropy_bytes:
            print(f"End of '{ENTROPY_BUS_FILENAME}' reached. Looping from start for demonstration.")
            entropy_file.seek(0) # Loop back to start of file
            entropy_bytes = entropy_file.read(2)
            if not entropy_bytes: # If file is empty even after seeking
                print(f"Error: '{ENTROPY_BUS_FILENAME}' is empty.")
                break

        entropy_value = struct.unpack('>H', entropy_bytes)[0] # '>H' for big-endian unsigned short

        # 2. Simulate chaos_score (Placeholder for actual chaos signal from Verilog)
        simulated_chaos_score = int((entropy_value * 0.7) + (np.random.rand() * 15000) + (i * 20))
        simulated_chaos_score = min(max(simulated_chaos_score, 0), 65535) # Clip to 16-bit range

        # 3. Simulate IPC Variance (Placeholder for actual IPC Variance from Verilog)
        # This will be generated by your system's performance monitoring unit
        simulated_ipc_variance = int((np.sin(i / 50.0) + 1) / 2.0 * 65535 * 0.5 + (np.random.rand() * 5000)) # Sinusoidal with noise
        simulated_ipc_variance = min(max(simulated_ipc_variance, 0), 65535) # Clip to 16-bit range


        # 4. Predict action using the loaded LSTM model with all 3 features
        ml_action_code = predict_action_func(entropy_value, simulated_chaos_score, simulated_ipc_variance)

        # 5. Write prediction to ml_predictions.txt
        predictions_file.write(f"{ml_action_code}\n")

        print(f"Cycle {i+1}: E={entropy_value}, C={simulated_chaos_score}, IPC_Var={simulated_ipc_variance}, ML_Prediction={ml_action_code}")

        # Optional: Add a small delay to simulate real-time processing
        # time.sleep(0.001)

    print(f"\nCo-simulation finished. Generated {num_cycles} ML predictions to '{ML_PREDICTIONS_FILENAME}'.")

    # Close files
    entropy_file.close()
    predictions_file.close()
    print("Files closed.")

if __name__ == "__main__":
    # Ensure you have run chaos_lstm_predictor.py at least once
    # to generate model.h5 and scaler_params.npy before running this.
    # Also, ensure generate_entropy_bus.py has been run to create entropy_bus.txt.
    ml_verilog_cosim_driver(num_cycles=500) # Adjust cycles as needed for your simulation